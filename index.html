<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—3Dã‚¸ãƒ£ãƒ¼ãƒ‹ãƒ¼ - Responsive</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;700&display=swap');
        
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            margin: 0;
            font-family: 'Noto Sans JP', sans-serif;
            overflow: hidden;
            background: #0a0a0a;
            cursor: grab;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        
        body:active {
            cursor: grabbing;
        }
        
        /* Base font size for responsive scaling */
        html {
            font-size: 16px;
        }
        
        /* Info Panel */
        #info {
            position: absolute;
            top: 1rem;
            left: 1rem;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 1.25rem;
            border-radius: 0.9375rem;
            max-width: 380px;
            backdrop-filter: blur(10px);
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            transition: transform 0.3s ease;
        }
        
        /* Info Panel Toggle for Mobile */
        #info-toggle {
            display: none;
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 3rem;
            height: 3rem;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 101;
            font-size: 1.5rem;
            backdrop-filter: blur(10px);
        }
        
        /* Controls */
        #controls {
            position: absolute;
            bottom: 1.25rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 1.25rem 1.875rem;
            border-radius: 0.9375rem;
            backdrop-filter: blur(10px);
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.9375rem;
            max-width: 90vw;
        }
        
        .control-row {
            display: flex;
            gap: 0.625rem;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            margin: 0 0.3125rem;
            padding: 0.625rem 1.25rem;
            background: #0ea5e9;
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.3s;
            font-weight: 500;
            min-height: 44px;
            min-width: 44px;
            touch-action: manipulation;
        }
        
        button:hover, button:active {
            background: #0284c7;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 165, 233, 0.4);
        }
        
        button.active {
            background: #f59e0b;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
        }
        
        button.sub-stage-btn {
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            background: #475569;
        }
        
        button.sub-stage-btn.active {
            background: #10b981;
        }
        
        h2 {
            margin-top: 0;
            color: #0ea5e9;
            font-size: 1.5rem;
            font-weight: 700;
        }
        
        h3 {
            color: #f59e0b;
            font-size: 1.125rem;
            margin-top: 0.9375rem;
            font-weight: 700;
        }
        
        .dimension-label {
            color: #94a3b8;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 0.9375rem;
            font-weight: 700;
        }
        
        .dimension-content {
            margin-top: 0.3125rem;
            font-size: 0.875rem;
            line-height: 1.6;
            color: #e2e8f0;
        }
        
        .stage-description {
            margin-top: 0.625rem;
            font-size: 0.875rem;
            line-height: 1.6;
            color: #cbd5e1;
        }
        
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.25rem;
            z-index: 200;
        }
        
        /* Legend */
        .legend {
            position: absolute;
            top: 1.25rem;
            right: 1.25rem;
            background: rgba(0, 0, 0, 0.8);
            padding: 1.25rem;
            border-radius: 0.9375rem;
            backdrop-filter: blur(10px);
            color: white;
            font-size: 0.75rem;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 0.5rem 0;
        }
        
        .legend-color {
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 50%;
            margin-right: 0.625rem;
            box-shadow: 0 0 10px currentColor;
        }
        
        #particle-info {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 0.9375rem;
            border-radius: 0.625rem;
            font-size: 0.875rem;
            pointer-events: none;
            z-index: 150;
            display: none;
            max-width: 250px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }
        
        /* Journey Progress */
        #journey-progress {
            position: absolute;
            top: 50%;
            right: 1.25rem;
            transform: translateY(-50%);
            width: 3.75rem;
            height: auto;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 1.875rem;
            padding: 1.25rem 0.625rem;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .progress-node {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            background: #1e293b;
            margin: 1.25rem auto;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            color: #64748b;
            font-weight: 700;
            touch-action: manipulation;
        }
        
        .progress-node.active {
            background: #0ea5e9;
            color: white;
            box-shadow: 0 0 20px #0ea5e9;
            transform: scale(1.2);
        }
        
        .progress-node.completed {
            background: #10b981;
            color: white;
        }
        
        /* Sound Toggle */
        .sound-toggle {
            position: absolute;
            bottom: 1.25rem;
            right: 1.25rem;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            width: 3.125rem;
            height: 3.125rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            color: white;
            font-size: 1.25rem;
            touch-action: manipulation;
        }
        
        .path-toggle {
            background: #8b5cf6;
        }
        
        .path-toggle:hover {
            background: #7c3aed;
        }
        
        /* Tutorial */
        #tutorial {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 2.5rem;
            border-radius: 1.25rem;
            max-width: min(500px, 90vw);
            z-index: 300;
            text-align: center;
            display: none;
            border: 2px solid #0ea5e9;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        #tutorial h2 {
            color: #0ea5e9;
            margin-bottom: 1.25rem;
        }
        
        #tutorial p {
            line-height: 1.8;
            margin-bottom: 1.875rem;
            font-size: 0.875rem;
        }
        
        .highlight {
            color: #f59e0b;
            font-weight: 700;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 0.9375rem;
            margin-top: 0.625rem;
        }
        
        input[type="range"] {
            width: 12.5rem;
            height: 0.375rem;
            background: #334155;
            outline: none;
            border-radius: 0.1875rem;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 1.125rem;
            height: 1.125rem;
            background: #0ea5e9;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .speed-label {
            color: #94a3b8;
            font-size: 0.75rem;
            min-width: 3.75rem;
        }
        
        /* Mobile Menu Toggle */
        #mobile-menu-toggle {
            display: none;
            position: fixed;
            bottom: 1.25rem;
            left: 1.25rem;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 3.5rem;
            height: 3.5rem;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 102;
            font-size: 1.5rem;
            backdrop-filter: blur(10px);
        }
        
        /* Tablet Styles */
        @media (max-width: 1024px) {
            html {
                font-size: 15px;
            }
            
            #info {
                max-width: 320px;
            }
            
            .legend {
                font-size: 0.7rem;
                padding: 1rem;
            }
            
            #journey-progress {
                width: 3.125rem;
            }
            
            .progress-node {
                width: 2rem;
                height: 2rem;
                font-size: 0.625rem;
                margin: 1rem auto;
            }
        }
        
        /* Mobile Styles */
        @media (max-width: 768px) {
            html {
                font-size: 14px;
            }
            
            /* Hide/Show elements for mobile */
            #info {
                left: -100%;
                top: 0;
                right: auto;
                bottom: 0;
                max-width: 80vw;
                height: 100vh;
                border-radius: 0;
                overflow-y: auto;
            }
            
            #info.show {
                left: 0;
            }
            
            #info-toggle {
                display: flex;
            }
            
            .legend {
                display: none;
            }
            
            /* Horizontal progress bar for mobile */
            #journey-progress {
                top: auto;
                bottom: 5rem;
                left: 50%;
                right: auto;
                transform: translateX(-50%);
                width: 90vw;
                height: 3.75rem;
                display: flex;
                flex-direction: row;
                padding: 0.625rem 1.25rem;
                overflow-x: auto;
                overflow-y: hidden;
                -webkit-overflow-scrolling: touch;
            }
            
            .progress-node {
                margin: 0 0.625rem;
                flex-shrink: 0;
            }
            
            /* Simplified controls */
            #controls {
                bottom: 0.625rem;
                padding: 0.75rem 1rem;
                width: 95vw;
                display: none;
            }
            
            #controls.show {
                display: flex;
            }
            
            #mobile-menu-toggle {
                display: flex;
            }
            
            .control-row {
                gap: 0.375rem;
            }
            
            button {
                padding: 0.5rem 0.875rem;
                font-size: 0.75rem;
            }
            
            button.sub-stage-btn {
                padding: 0.375rem 0.625rem;
                font-size: 0.625rem;
            }
            
            .slider-container {
                width: 100%;
            }
            
            input[type="range"] {
                flex: 1;
            }
            
            /* Particle info centered for mobile */
            #particle-info {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                max-width: 80vw;
            }
            
            /* Sound toggle repositioned */
            .sound-toggle {
                bottom: auto;
                top: 1.25rem;
                right: 1.25rem;
            }
        }
        
        /* Landscape Mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            #journey-progress {
                bottom: 0.5rem;
                height: 3rem;
            }
            
            .progress-node {
                width: 2rem;
                height: 2rem;
            }
            
            #controls {
                bottom: 0.375rem;
                padding: 0.5rem 0.875rem;
            }
            
            #controls .control-row {
                gap: 0.25rem;
            }
            
            button {
                padding: 0.375rem 0.75rem;
                font-size: 0.625rem;
                min-height: 36px;
            }
        }
        
        /* Small Mobile */
        @media (max-width: 480px) {
            html {
                font-size: 13px;
            }
            
            #tutorial {
                padding: 1.5rem;
            }
            
            h2 {
                font-size: 1.25rem;
            }
            
            h3 {
                font-size: 1rem;
            }
        }
        
        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation: none !important;
                transition: none !important;
            }
        }
        
        /* High contrast mode support */
        @media (prefers-contrast: high) {
            button {
                border: 2px solid white;
            }
            
            .progress-node {
                border: 2px solid white;
            }
        }
    </style>
</head>
<body>
    <div id="loader">Loading...</div>
    
    <div id="info-toggle" onclick="toggleInfoPanel()" aria-label="æƒ…å ±ãƒ‘ãƒãƒ«åˆ‡ã‚Šæ›¿ãˆ">â„¹ï¸</div>
    
    <div id="tutorial">
        <h2>ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—3Dã‚¸ãƒ£ãƒ¼ãƒ‹ãƒ¼ã¸ã‚ˆã†ã“ã</h2>
        <p>
            ã“ã®3Dç©ºé–“ã§ã¯ã€<span class="highlight">è‡ªå·±ã®æˆé•·</span>ã‚’è¦–è¦šçš„ã«ä½“é¨“ã§ãã¾ã™ã€‚<br><br>
            <strong>æ“ä½œæ–¹æ³•ï¼š</strong><br>
            <span id="control-instructions">
                â€¢ ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°ã§è¦–ç‚¹ã‚’å›è»¢<br>
                â€¢ ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ <br>
                â€¢ ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ã‚¯ãƒªãƒƒã‚¯ã§è©³ç´°è¡¨ç¤º<br>
                â€¢ å³å´ã®ãƒãƒ¼ãƒ‰ã§æ®µéšã‚’ç›´æ¥é¸æŠ<br><br>
            </span>
            <strong>3ã¤ã®æ¬¡å…ƒï¼š</strong><br>
            <span style="color: #3b82f6;">é’</span>ï¼šèªè­˜è«–çš„æ¬¡å…ƒ<br>
            <span style="color: #10b981;">ç·‘</span>ï¼šå¯¾è‡ªé–¢ä¿‚æ¬¡å…ƒ<br>
            <span style="color: #f59e0b;">æ©™</span>ï¼šå¯¾äººé–¢ä¿‚æ¬¡å…ƒ
        </p>
        <button onclick="closeTutorial()">å§‹ã‚ã‚‹</button>
    </div>
    
    <div id="info">
        <h2>ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æ—…</h2>
        <div id="stage-info">
            <h3 id="current-stage">å¤–çš„æ„å‘³å½¢æˆ</h3>
            <div class="stage-description" id="stage-description">
                å¤–éƒ¨ã®æ¨©å¨ã‚„ä»–è€…ã®æœŸå¾…ã«ä¾å­˜ã—ã¦æ„å‘³ã‚’å½¢æˆã™ã‚‹æ®µéš
            </div>
            <div style="margin-top: 15px;">
                <div class="dimension-label">èªè­˜è«–çš„æ¬¡å…ƒ</div>
                <div class="dimension-content" id="epistemological">çŸ¥è­˜ã¯æ¨©å¨ã‹ã‚‰ä¸ãˆã‚‰ã‚Œã‚‹ã‚‚ã®</div>
            </div>
            <div style="margin-top: 10px;">
                <div class="dimension-label">å¯¾è‡ªé–¢ä¿‚æ¬¡å…ƒ</div>
                <div class="dimension-content" id="intrapersonal">è‡ªå·±ã¯ä»–è€…ã®è©•ä¾¡ã«ä¾å­˜</div>
            </div>
            <div style="margin-top: 10px;">
                <div class="dimension-label">å¯¾äººé–¢ä¿‚æ¬¡å…ƒ</div>
                <div class="dimension-content" id="interpersonal">ä»–è€…ã‹ã‚‰ã®æ‰¿èªã‚’æ±‚ã‚ã‚‹é–¢ä¿‚</div>
            </div>
        </div>
    </div>
    
    <div class="legend">
        <h4 style="margin-top: 0; color: #0ea5e9;">è¦–è¦šçš„ã‚¬ã‚¤ãƒ‰</h4>
        <div class="legend-item">
            <div class="legend-color" style="background: #3b82f6;"></div>
            <span>èªè­˜è«–çš„æ¬¡å…ƒ</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #10b981;"></div>
            <span>å¯¾è‡ªé–¢ä¿‚æ¬¡å…ƒ</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f59e0b;"></div>
            <span>å¯¾äººé–¢ä¿‚æ¬¡å…ƒ</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ffffff;"></div>
            <span>è‡ªå·±ï¼ˆã‚³ã‚¢ï¼‰</span>
        </div>
        <div class="legend-item" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.2);">
            <div class="legend-color" style="background: linear-gradient(45deg, #3b82f6, #10b981, #f59e0b);"></div>
            <span>å†…ãªã‚‹å…‰ã®æ”¾å°„</span>
        </div>
    </div>
    
    <div id="journey-progress">
        <div class="progress-node" onclick="jumpToStage('Ea')" title="å¤–çš„æ¨©å¨ã‚’ä¿¡é ¼">Ea</div>
        <div class="progress-node" onclick="jumpToStage('Eb')" title="ç·Šå¼µã®çµŒé¨“">Eb</div>
        <div class="progress-node" onclick="jumpToStage('Ec')" title="æ¬ ç‚¹ã®èªè­˜">Ec</div>
        <div class="progress-node" onclick="jumpToStage('EI')" title="ç–‘å•ã‚’æŒã¤">E(I)</div>
        <div class="progress-node" onclick="jumpToStage('E-I')" title="å†…ãªã‚‹å£°ã‚’æ§‹ç¯‰">E-I</div>
        <div class="progress-node" onclick="jumpToStage('I-E')" title="å†…ãªã‚‹å£°ã‚’è´ã">I-E</div>
        <div class="progress-node" onclick="jumpToStage('IE')" title="å†…ãªã‚‹å£°ã‚’è‚²ã‚€">I(E)</div>
        <div class="progress-node" onclick="jumpToStage('Ia')" title="å†…ãªã‚‹å£°ã‚’ä¿¡é ¼">Ia</div>
        <div class="progress-node" onclick="jumpToStage('Ib')" title="å†…ãªã‚‹åŸºç›¤ã‚’ç¯‰ã">Ib</div>
        <div class="progress-node" onclick="jumpToStage('Ic')" title="ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆç¢ºä¿">Ic</div>
    </div>
    
    <div id="mobile-menu-toggle" onclick="toggleMobileMenu()" aria-label="ãƒ¡ãƒ‹ãƒ¥ãƒ¼åˆ‡ã‚Šæ›¿ãˆ">â˜°</div>
    
    <div id="controls">
        <div class="control-row">
            <button onclick="showStage('external')" class="main-stage-btn active">å¤–çš„æ„å‘³å½¢æˆ</button>
            <button onclick="showStage('crossroads')" class="main-stage-btn">å²è·¯</button>
            <button onclick="showStage('internal')" class="main-stage-btn">å†…çš„æ„å‘³å½¢æˆ</button>
        </div>
        <div class="control-row" id="sub-stage-controls">
            <!-- ã‚µãƒ–ã‚¹ãƒ†ãƒ¼ã‚¸ãƒœã‚¿ãƒ³ã¯å‹•çš„ã«ç”Ÿæˆ -->
        </div>
        <div class="control-row">
            <button onclick="toggleAnimation()" id="animation-toggle">è‡ªå‹•é€²è¡Œ: ON</button>
            <button onclick="togglePath()" class="path-toggle">å†…ãªã‚‹å…‰: OFF</button>
            <button onclick="resetView()">è¦–ç‚¹ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
        <div class="slider-container">
            <span class="speed-label">é€Ÿåº¦:</span>
            <input type="range" id="speed-slider" min="0" max="2" step="0.1" value="1" aria-label="ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é€Ÿåº¦">
            <span class="speed-label" id="speed-value">1.0x</span>
        </div>
    </div>
    
    <div class="sound-toggle" onclick="toggleSound()" title="ã‚µã‚¦ãƒ³ãƒ‰åˆ‡ã‚Šæ›¿ãˆ" aria-label="ã‚µã‚¦ãƒ³ãƒ‰åˆ‡ã‚Šæ›¿ãˆ">
        ğŸ”Š
    </div>
    
    <div id="particle-info"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let particles = [];
        let core;
        let dimensionRings = [];
        let currentStage = 'external';
        let currentSubStage = 'Ea';
        let animationRunning = true;
        let time = 0;
        let soundEnabled = true;
        let pathEnabled = false;
        let journeyPath;
        let raycaster, mouse;
        let controls;
        let speedMultiplier = 1;
        let isMobile = false;
        let isTablet = false;
        let particleCount = 150;
        
        // Audio context for sound effects
        let audioContext;
        let oscillator;
        
        // Touch handling variables
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartDistance = 0;
        let cameraDistance = 10;
        
        // Detailed stage data
        const subStageData = {
            'Ea': {
                name: 'Ea: å¤–çš„æ¨©å¨ã‚’ä¿¡é ¼ã™ã‚‹',
                parent: 'external',
                description: 'ä¸€è²«ã—ã¦ç›²ç›®çš„ã«å¤–çš„è³‡æºã‚’ä¿¡é ¼ã—ã€ãã®æ¬ ç‚¹ã®å¯èƒ½æ€§ã‚’èªè­˜ã—ãªã„',
                epistemological: 'çŸ¥è­˜ã¯æ¨©å¨ã‹ã‚‰ä¸ãˆã‚‰ã‚Œã‚‹çµ¶å¯¾çš„ãªã‚‚ã®ã€‚æ¨©å¨ã®è¨€ã†ã“ã¨ãŒæ­£è§£',
                intrapersonal: 'è‡ªå·±ã®å®šç¾©ã¯ä»–è€…ã‹ã‚‰ã®è©•ä¾¡ã‚„æœŸå¾…ã«å®Œå…¨ã«ä¾å­˜',
                interpersonal: 'ä»–è€…ã‹ã‚‰ã®æ‰¿èªã‚’å¼·ãæ±‚ã‚ã€æ¨©å¨ã‚„å¤šæ•°æ´¾ã«åŒèª¿ã™ã‚‹å‚¾å‘',
                coreSize: 0.2,
                particleSpread: 6,
                ringRotation: 0.008,
                coreColor: 0x4a5568,
                intensity: 0.3
            },
            'Eb': {
                name: 'Eb: å¤–çš„æ¨©å¨ä¿¡é ¼ã®ç·Šå¼µ',
                parent: 'external',
                description: 'å¤–çš„è³‡æºã‚’ä¿¡é ¼ã™ã‚‹ãŒã€ç‰¹ã«è³‡æºé–“ã«è‘›è—¤ãŒã‚ã‚‹å ´åˆã«ç·Šå¼µã‚’çµŒé¨“',
                epistemological: 'è¤‡æ•°ã®æ¨©å¨ãŒç•°ãªã‚‹ã“ã¨ã‚’è¨€ã†å ´é¢ã«ç›´é¢ã—ã€çŸ¥è­˜ã®çµ¶å¯¾æ€§ã«æºã‚‰ãã‚’æ„Ÿã˜å§‹ã‚ã‚‹',
                intrapersonal: 'å¤–çš„æœŸå¾…ã®é–“ã§æ¿æŒŸã¿ã«ãªã‚Šã€è‡ªå·±ã®æ„Ÿè¦šã«é•å’Œæ„Ÿã‚„å±…å¿ƒåœ°ã®æ‚ªã•ã‚’æ„Ÿã˜å§‹ã‚ã‚‹',
                interpersonal: 'ç•°ãªã‚‹æœŸå¾…ã‚„æ„è¦‹ã®é–“ã§è‘›è—¤ã—ã€é–¢ä¿‚æ€§ã®èª¿æ•´ã«å›°é›£ã‚’æ„Ÿã˜ã‚‹',
                coreSize: 0.3,
                particleSpread: 5,
                ringRotation: 0.012,
                coreColor: 0x64748b,
                intensity: 0.4
            },
            'Ec': {
                name: 'Ec: å¤–çš„æ¨©å¨ä¿¡é ¼ã®æ¬ ç‚¹èªè­˜',
                parent: 'external',
                description: 'å¤–çš„æ¨©å¨ã¸ã®ä¿¡é ¼ã‚’ç¶™ç¶šã™ã‚‹ãŒã€ãã®æ¬ ç‚¹ã‚’èªè­˜ã—ã¦ã„ã‚‹',
                epistemological: 'çŸ¥è­˜ã®ç›¸å¯¾æ€§ã‚„ä¸ç¢ºå®Ÿæ€§ã«æ°—ã¥ãå§‹ã‚ã‚‹ã€‚æ¨©å¨ã«ä¾å­˜ã™ã‚‹ã“ã¨ã®é™ç•Œã‚’è‡ªè¦š',
                intrapersonal: 'ã€Œè‡ªåˆ†ã¯ä½•è€…ã‹ã€ã¨ã„ã†å•ã„ãŒç”Ÿã¾ã‚Œå§‹ã‚ã‚‹ã€‚å¤–çš„ãªæ¨©å¨ã«ä¾å­˜ã™ã‚‹ã“ã¨ã¸ã®ãƒ•ãƒ©ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³',
                interpersonal: 'ä»–è€…ã®æ‰¿èªã‚’æ±‚ã‚ç¶šã‘ã‚‹ãŒã€ãã“ã«é™ç•Œã‚’æ„Ÿã˜ã‚‹ã€‚é–¢ä¿‚ã«ãŠã‘ã‚‹è‡ªå·±ã®ã‚ã‚Šæ–¹ã«ã¤ã„ã¦è€ƒãˆå§‹ã‚ã‚‹',
                coreSize: 0.4,
                particleSpread: 4.5,
                ringRotation: 0.015,
                coreColor: 0x94a3b8,
                intensity: 0.5
            },
            'EI': {
                name: 'E(I): å¤–çš„æ¨©å¨ã«ç–‘å•ã‚’æŒã¤',
                parent: 'crossroads',
                description: 'å†…ãªã‚‹å£°ã®å¿…è¦æ€§ã‚’è‡ªè¦šã™ã‚‹ã‚‚ã€å¤–çš„è³‡æºã¸ã®ä¿¡é ¼ã‚’ç¶™ç¶š',
                epistemological: 'æ¨©å¨ã‚„æ—¢å­˜ã®çŸ¥è­˜ã«ç–‘å•ã‚’æŠ±ãå§‹ã‚ã‚‹ã€‚è‡ªåˆ†ã®è€ƒãˆã‚„è¦–ç‚¹ã®é‡è¦æ€§ã‚’èªè­˜',
                intrapersonal: 'ã€Œè‡ªåˆ†ã¯ã©ã†ã—ãŸã„ã®ã‹ã€ã¨ã„ã†å†…çš„ãªå•ã„ãŒå¼·ã¾ã‚‹ã€‚è‡ªå·±æ±ºå®šã®å¿…è¦æ€§ã‚’æ„Ÿã˜ã‚‹ãŒè‡ªä¿¡ãŒãªã„',
                interpersonal: 'ä»–è€…ã®æœŸå¾…ã¨è‡ªåˆ†ã®è€ƒãˆã®é–“ã§æºã‚Œå‹•ãã€‚é–¢ä¿‚ã®ä¸­ã§è‡ªåˆ†ã®æ„è¦‹ã‚’è¡¨æ˜ã™ã‚‹ã“ã¨ã«ãŸã‚ã‚‰ã„',
                coreSize: 0.5,
                particleSpread: 3.8,
                ringRotation: 0.018,
                coreColor: 0x0ea5e9,
                intensity: 0.6
            },
            'E-I': {
                name: 'E-I: å†…ãªã‚‹å£°ã‚’æ§‹ç¯‰ã™ã‚‹',
                parent: 'crossroads',
                description: 'æ„å‘³å½¢æˆã®æ–°ã—ã„ä»•æ–¹ã‚’æ§‹ç¯‰ã™ã‚‹ã‚ˆã†èƒ½å‹•çš„ã«å‹•ãå§‹ã‚ã‚‹ãŒã€æ™‚ã«å¾Œé€€ã‚‚',
                epistemological: 'è‡ªåˆ†ã®è€ƒãˆã‚„åˆ¤æ–­åŸºæº–ã‚’ç©æ¥µçš„ã«æ§‹ç¯‰ã—ã‚ˆã†ã¨è©¦ã¿ã‚‹ã€‚æ‰¹åˆ¤çš„ã«æ¤œè¨ã—å§‹ã‚ã‚‹ãŒã€æ™‚ã«å¤–çš„æ¨©å¨ã«é ¼ã‚‹',
                intrapersonal: 'å†…ãªã‚‹å£°ï¼ˆä¾¡å€¤è¦³ã€ä¿¡å¿µï¼‰ã‚’æ„è­˜çš„ã«å½¢æˆã—ã‚ˆã†ã¨ã™ã‚‹ã€‚è‡ªå·±æ¢æ±‚ãŒæ´»ç™ºã«ãªã‚‹ãŒã€ä¸å®‰ã‚„æ··ä¹±ã‚‚',
                interpersonal: 'è‡ªåˆ†ã®è€ƒãˆã‚’ä»–è€…ã«ä¼ãˆã€é–¢ä¿‚ã®ä¸­ã§è©¦è¡ŒéŒ¯èª¤ã™ã‚‹ã€‚å¤–çš„å½±éŸ¿ã¨å†…çš„å¿—å‘ã®é–“ã§ç·Šå¼µ',
                coreSize: 0.6,
                particleSpread: 3.2,
                ringRotation: 0.02,
                coreColor: 0x3b82f6,
                intensity: 0.7
            },
            'I-E': {
                name: 'I-E: å†…ãªã‚‹å£°ã‚’è´ã',
                parent: 'crossroads',
                description: 'å†…ãªã‚‹å£°ã‚’æ³¨æ„æ·±ãèãå–ã‚Šå§‹ã‚ã€å¤–çš„è³‡æºã‚’æŠ¼ã—ã®ã‘ã¤ã¤ã‚ã‚‹',
                epistemological: 'å†…çš„ãªåˆ¤æ–­åŸºæº–ãŒæ˜ç¢ºã«ãªã‚Šå§‹ã‚ã‚‹ã€‚å¤–çš„æƒ…å ±ã‚’éµœå‘‘ã¿ã«ã›ãšã€è‡ªåˆ†ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’é€šã—ã¦è§£é‡ˆ',
                intrapersonal: 'è‡ªåˆ†ã®æ„Ÿæƒ…ã‚„æ¬²æ±‚ã«æ³¨æ„ã‚’æ‰•ã„ã€ãã‚Œã«åŸºã¥ã„ã¦æ„æ€æ±ºå®šã—ã‚ˆã†ã¨ã™ã‚‹ã€‚è‡ªå·±ä¿¡é ¼æ„ŸãŒå¢—ã—å§‹ã‚ã‚‹',
                interpersonal: 'ä»–è€…ã®è¦–ç‚¹ã‚’å°Šé‡ã—ã¤ã¤ã‚‚ã€è‡ªåˆ†ã®æ„è¦‹ã‚’åŒºåˆ¥ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚å¤–çš„å½±éŸ¿ã‚’ç®¡ç†ã™ã‚‹æ„è­˜',
                coreSize: 0.7,
                particleSpread: 2.5,
                ringRotation: 0.022,
                coreColor: 0x10b981,
                intensity: 0.75
            },
            'IE': {
                name: 'I(E): å†…ãªã‚‹å£°ã‚’è‚²ã‚€',
                parent: 'crossroads',
                description: 'å†…ãªã‚‹å£°ã‚’èƒ½å‹•çš„ã«è‚²ã¿å§‹ã‚ã€å¤–çš„è³‡æºã‚’å‡Œé§•ã™ã‚‹',
                epistemological: 'è‡ªåˆ†ã®è€ƒãˆã‚„è¦–ç‚¹ã‚’ç”Ÿã¿å‡ºã™ã“ã¨ã‚’è‡ªå·±èªè­˜ã—ã€ç©æ¥µçš„ã«ç™ºå±•ã•ã›ã‚‹ã€‚çŸ¥è­˜æ§‹ç¯‰ã®ä¸»ä½“ã¨ã—ã¦ã®è‡ªè¦š',
                intrapersonal: 'è‡ªå·±æ´å¯Ÿã‚’æ·±ã‚ã€èˆˆå‘³é–¢å¿ƒã‚„æ¬²æ±‚ã‚’åˆ†æã€‚å†…ãªã‚‹å£°ã‚’ç”¨ã„ã‚‹ã“ã¨ã«è‡ªä¿¡ã‚’æŒã¡å§‹ã‚ã‚‹ãŒã€æ™‚ã«å¤–çš„å½±éŸ¿ã«æºã‚‰ã',
                interpersonal: 'ä»–è€…ã¨ã®é–¢ä¿‚ã«ãŠã„ã¦ã€è‡ªåˆ†ã®å†…ãªã‚‹å£°ã«åŸºã¥ã„ã¦è¡Œå‹•ã—ã‚ˆã†ã¨ã™ã‚‹ã€‚å¤–çš„å½±éŸ¿ã‚’ãƒãƒã‚¸ãƒ¡ãƒ³ãƒˆã™ã‚‹æ„è­˜ãŒé«˜ã¾ã‚‹',
                coreSize: 0.8,
                particleSpread: 2,
                ringRotation: 0.025,
                coreColor: 0x22c55e,
                intensity: 0.8
            },
            'Ia': {
                name: 'Ia: å†…ãªã‚‹å£°ã‚’ä¿¡é ¼ã™ã‚‹',
                parent: 'internal',
                description: 'ä¿¡å¿µç­‰ã‚’æ´—ç·´ã™ã‚‹ã®ã«ååˆ†å†…ãªã‚‹å£°ã‚’ä¿¡é ¼ã€‚å¤–çš„è³‡æºã‚’ç®¡ç†',
                epistemological: 'å†…çš„ãªåˆ¤æ–­åŸºæº–ã‚„ä¿¡å¿µä½“ç³»ãŒç¢ºç«‹ã•ã‚Œã€ãã‚Œã«åŸºã¥ã„ã¦çŸ¥è­˜ã‚’ä¸»ä½“çš„ã«è§£é‡ˆãƒ»è©•ä¾¡ã€‚çŸ¥è­˜æ§‹ç¯‰ã®ä¿æœ‰è€…ã¨ã—ã¦ã®è²¬ä»»',
                intrapersonal: 'å†…ãªã‚‹å£°ã¸ã®ä¿¡é ¼ãŒç¢ºå›ºãŸã‚‹ã‚‚ã®ã¨ãªã‚Šã€è‡ªå·±æ±ºå®šã«è‡ªä¿¡ã‚’æŒã¤ã€‚å›°é›£ãªçŠ¶æ³ã§ã‚‚æ„Ÿæƒ…ã‚’ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«',
                interpersonal: 'å¤–çš„å½±éŸ¿ã‚’åˆ†æãƒ»èª¿æ•´ã—ãªãŒã‚‰ã€è‡ªåˆ†ã®å†…ãªã‚‹å£°ã«åŸºã¥ã„ã¦ä»–è€…ã¨é–¢ä¿‚ã‚’æ§‹ç¯‰ã€‚ç›¸äº’å°Šé‡ã«åŸºã¥ã„ãŸè‡ªå¾‹çš„ãªé–¢ä¿‚',
                coreSize: 0.9,
                particleSpread: 1.5,
                ringRotation: 0.028,
                coreColor: 0xf59e0b,
                intensity: 0.85
            },
            'Ib': {
                name: 'Ib: å†…ãªã‚‹åŸºç›¤ã‚’ç¯‰ã',
                parent: 'internal',
                description: 'äººç”Ÿå“²å­¦ã¸ã®ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆã‚’å½¢æˆã™ã‚‹ã®ã«ååˆ†å†…ãªã‚‹å£°ã‚’ä¿¡é ¼',
                epistemological: 'å†…ãªã‚‹å£°ã¨å¤–çš„å½±éŸ¿ã‚’çµ±åˆã—ã€ä¸€è²«ã—ãŸäººç”Ÿå“²å­¦ã‚„ä¸–ç•Œè¦³ã‚’å½¢æˆã€‚çŸ¥è­˜ã‚’çŸ¥æµã¸ã¨æ˜‡è¯',
                intrapersonal: 'è‡ªå·±ã®å¼±ã¿ã‚‚ç›´è¦–ã—ã€å†…ãªã‚‹å£°ã¨ãã‚Œã«åŸºã¥ãè‡ªå·±æ±ºå®šã‚’é‡ã­ã‚‹ã“ã¨ã§ã€å†…çš„ãªåŸºç›¤ã‚’å¼·å›ºã«',
                interpersonal: 'è‡ªå·±ã®äººç”Ÿå“²å­¦ã«åŸºã¥ã„ã¦ä»–è€…ã‚„ç¤¾ä¼šã¨é–¢ã‚ã‚‹ã€‚å¤šæ§˜ãªä¾¡å€¤è¦³ã‚’ç†è§£ã—ã¤ã¤ã€è‡ªå·±ã®ç«‹å ´ã‚’æ˜ç¢ºã«',
                coreSize: 0.95,
                particleSpread: 1.2,
                ringRotation: 0.03,
                coreColor: 0xec4899,
                intensity: 0.9
            },
            'Ic': {
                name: 'Ic: å†…ãªã‚‹ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆã‚’ç¢ºä¿',
                parent: 'internal',
                description: 'äººç”Ÿå“²å­¦ã‚’è‡ªåˆ†ã®å­˜åœ¨ã®æ ¸ã¨ã—ã¦å›ºã‚ã€ç¬¬äºŒã®æ€§è³ªã¨ã—ã¦ç”Ÿãã‚‹',
                epistemological: 'çµ±åˆã•ã‚ŒãŸäººç”Ÿå“²å­¦ãŒè‡ªå·±ã®æ ¸ã¨ãªã‚Šã€ãã‚ŒãŒçŸ¥è­˜ã®è§£é‡ˆã‚„è¡Œå‹•ã®æŒ‡é‡ã¨ã—ã¦è‡ªç„¶ã«æ©Ÿèƒ½',
                intrapersonal: 'å†…ãªã‚‹åŸºç›¤ã¨å¤–çš„ç’°å¢ƒãŒèª¿å’Œçš„ã«çµ±åˆã•ã‚Œã€è‡ªå·±ã®å­˜åœ¨æ„ç¾©ã‚„äººç”Ÿã®ç›®çš„ãŒæ˜ç¢ºã«ã€‚ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆã¨å…±ã«ç”Ÿãã‚‹',
                interpersonal: 'è‡ªå·±ã®æ ¸ã¨ãªã‚‹ä¾¡å€¤è¦³ã«åŸºã¥ã„ã¦ã€ä»–è€…ã‚„ç¤¾ä¼šã«è²¢çŒ®ã—ã‚ˆã†ã¨ã™ã‚‹ã€‚çœŸã®ç›¸äº’ä¾å­˜é–¢ä¿‚ã®ä¸­ã§è‡ªå·±å®Ÿç¾',
                coreSize: 1,
                particleSpread: 1,
                ringRotation: 0.035,
                coreColor: 0xffffff,
                intensity: 1
            }
        };
        
        // Experience examples for particles
        const experienceExamples = {
            external: [
                "æ•™æˆã®è¨€ã†ã“ã¨ã‚’çµ¶å¯¾è¦–ã™ã‚‹",
                "è¦ªã®æœŸå¾…ã«å¿œãˆã‚ˆã†ã¨ã™ã‚‹",
                "å‹äººã®æ„è¦‹ã«æµã•ã‚Œã‚‹",
                "æˆç¸¾ã§è‡ªå·±ä¾¡å€¤ã‚’æ¸¬ã‚‹",
                "æ¨©å¨ã‚ã‚‹æœ¬ã‚’éµœå‘‘ã¿ã«ã™ã‚‹",
                "å¤šæ•°æ´¾ã®æ„è¦‹ã«å¾“ã†",
                "è©•ä¾¡ã‚’æ°—ã«ã—ã¦è¡Œå‹•ã‚’æ±ºã‚ã‚‹",
                "ä»–è€…ã®æ‰¿èªã‚’æ±‚ã‚ã‚‹"
            ],
            crossroads: [
                "è‡ªåˆ†ã®æ„è¦‹ã‚’æŒã¡å§‹ã‚ã‚‹",
                "æ¨©å¨ã«ç–‘å•ã‚’æ„Ÿã˜ã‚‹",
                "å†…ãªã‚‹å£°ã«è€³ã‚’å‚¾ã‘ã‚‹",
                "è‡ªå·±æ¢æ±‚ã‚’å§‹ã‚ã‚‹",
                "ä¾¡å€¤è¦³ã®è¡çªã‚’çµŒé¨“",
                "è‡ªåˆ†ã‚‰ã—ã•ã‚’æ¨¡ç´¢ã™ã‚‹",
                "ç‹¬è‡ªã®åˆ¤æ–­åŸºæº–ã‚’ä½œã‚‹",
                "ä»–è€…ã¨ã®é•ã„ã‚’èªè­˜"
            ],
            internal: [
                "è‡ªå·±ã®ä¿¡å¿µã«åŸºã¥ã„ã¦æ±ºå®š",
                "å†…çš„ãªåŸºæº–ã§åˆ¤æ–­ã™ã‚‹",
                "ä»–è€…ã‚’å°Šé‡ã—ã¤ã¤è‡ªç«‹",
                "è‡ªå·±ã®ä¾¡å€¤è¦³ã‚’ç¢ºç«‹",
                "äººç”Ÿå“²å­¦ã‚’æŒã¤",
                "çœŸã®è‡ªå·±ã‚’è¡¨ç¾ã™ã‚‹",
                "ç›¸äº’ä¾å­˜çš„ãªé–¢ä¿‚ã‚’ç¯‰ã",
                "å†…ãªã‚‹å£°ã‚’ä¿¡é ¼ã™ã‚‹"
            ]
        };
        
        let tutorialShown = false;
        
        function checkDevice() {
            const width = window.innerWidth;
            isMobile = width <= 768;
            isTablet = width > 768 && width <= 1024;
            
            // Adjust particle count based on device
            if (isMobile) {
                particleCount = 60;
            } else if (isTablet) {
                particleCount = 100;
            } else {
                particleCount = 150;
            }
            
            // Update tutorial instructions based on device
            if (isMobile || isTablet) {
                const instructions = document.getElementById('control-instructions');
                if (instructions) {
                    instructions.innerHTML = `
                        â€¢ ã‚¿ãƒƒãƒãƒ‰ãƒ©ãƒƒã‚°ã§è¦–ç‚¹ã‚’å›è»¢<br>
                        â€¢ ãƒ”ãƒ³ãƒã§ã‚ºãƒ¼ãƒ <br>
                        â€¢ ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ã‚¿ãƒƒãƒ—ã§è©³ç´°è¡¨ç¤º<br>
                        â€¢ ä¸‹éƒ¨ã®ãƒãƒ¼ãƒ‰ã§æ®µéšã‚’ç›´æ¥é¸æŠ<br><br>
                    `;
                }
            }
        }
        
        function toggleInfoPanel() {
            const info = document.getElementById('info');
            info.classList.toggle('show');
        }
        
        function toggleMobileMenu() {
            const controls = document.getElementById('controls');
            controls.classList.toggle('show');
        }
        
        function init() {
            // Check device type
            checkDevice();
            
            // Show tutorial only once per session
            if (!tutorialShown) {
                document.getElementById('tutorial').style.display = 'block';
            }
            
            // éŸ³å£°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®åˆæœŸåŒ–
            initAudioContext();
            
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a0a0a, 10, 50);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, cameraDistance);
            camera.lookAt(0, 0, 0);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ 
                antialias: !isMobile,  // Disable antialiasing on mobile for performance
                powerPreference: isMobile ? "low-power" : "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
            renderer.shadowMap.enabled = !isMobile;  // Disable shadows on mobile
            if (renderer.shadowMap.enabled) {
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            }
            document.body.appendChild(renderer.domElement);
            
            // Initialize raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Mouse controls
            let mouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                mouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                mouseDown = false;
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (mouseDown) {
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    // Rotate camera around center
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position);
                    spherical.theta -= deltaX * 0.01;
                    spherical.phi += deltaY * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    camera.position.setFromSpherical(spherical);
                    camera.lookAt(0, 0, 0);
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }
                
                // Update mouse position for raycasting
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            
            // Mouse wheel for zoom
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const scale = e.deltaY > 0 ? 1.1 : 0.9;
                cameraDistance *= scale;
                cameraDistance = Math.max(5, Math.min(30, cameraDistance));
                camera.position.normalize().multiplyScalar(cameraDistance);
            });
            
            // Touch controls
            renderer.domElement.addEventListener('touchstart', handleTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', handleTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            // Click/Tap event for particles
            renderer.domElement.addEventListener('click', onParticleClick);
            renderer.domElement.addEventListener('touchend', (e) => {
                if (e.touches.length === 0 && e.changedTouches.length === 1) {
                    // Convert touch to mouse coordinates
                    const touch = e.changedTouches[0];
                    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                    onParticleClick(touch);
                }
            });
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, isMobile ? 0.6 : 0.5);
            scene.add(ambientLight);
            
            if (!isMobile) {
                const pointLight1 = new THREE.PointLight(0x0ea5e9, 2, 20);
                pointLight1.position.set(5, 5, 5);
                pointLight1.castShadow = true;
                scene.add(pointLight1);
                
                const pointLight2 = new THREE.PointLight(0xf59e0b, 2, 20);
                pointLight2.position.set(-5, 5, -5);
                pointLight2.castShadow = true;
                scene.add(pointLight2);
            }
            
            const pointLight3 = new THREE.PointLight(0x10b981, 1, 15);
            pointLight3.position.set(0, -5, 0);
            scene.add(pointLight3);
            
            // Create core (self)
            const coreGeometry = new THREE.SphereGeometry(0.3, isMobile ? 32 : 64, isMobile ? 32 : 64);
            const coreMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0x0ea5e9,
                emissiveIntensity: 0.5,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.castShadow = !isMobile;
            core.receiveShadow = !isMobile;
            scene.add(core);
            
            // Add glow effect to core
            const glowGeometry = new THREE.SphereGeometry(0.4, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x0ea5e9,
                transparent: true,
                opacity: 0.3
            });
            const coreGlow = new THREE.Mesh(glowGeometry, glowMaterial);
            core.add(coreGlow);
            
            // Create dimension rings with more detail
            const ringColors = [0x3b82f6, 0x10b981, 0xf59e0b];
            const ringRadii = [2, 3, 4];
            
            for (let i = 0; i < 3; i++) {
                const ringGeometry = new THREE.TorusGeometry(ringRadii[i], 0.1, 16, isMobile ? 50 : 100);
                const ringMaterial = new THREE.MeshPhongMaterial({
                    color: ringColors[i],
                    emissive: ringColors[i],
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.8
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                ring.castShadow = !isMobile;
                dimensionRings.push(ring);
                scene.add(ring);
                
                // Add orbital particles to rings (reduced for mobile)
                const orbitalCount = isMobile ? 10 : 20;
                for (let j = 0; j < orbitalCount; j++) {
                    const angle = (j / orbitalCount) * Math.PI * 2;
                    const orbitalGeometry = new THREE.SphereGeometry(0.03, 8, 8);
                    const orbitalMaterial = new THREE.MeshPhongMaterial({
                        color: ringColors[i],
                        emissive: ringColors[i],
                        emissiveIntensity: 0.8
                    });
                    const orbital = new THREE.Mesh(orbitalGeometry, orbitalMaterial);
                    orbital.position.set(
                        Math.cos(angle) * ringRadii[i],
                        0,
                        Math.sin(angle) * ringRadii[i]
                    );
                    ring.add(orbital);
                }
            }
            
            // Create particles representing experiences
            const particleGeometry = new THREE.SphereGeometry(0.05, isMobile ? 8 : 16, isMobile ? 8 : 16);
            
            for (let i = 0; i < particleCount; i++) {
                const hue = Math.random();
                const particleMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(hue, 0.7, 0.5),
                    emissive: new THREE.Color().setHSL(hue, 0.7, 0.5),
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.castShadow = !isMobile;
                
                // Random initial position
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 5 + 1;
                const height = (Math.random() - 0.5) * 4;
                
                particle.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                // Assign experience text
                const stageType = Math.random() < 0.33 ? 'external' : Math.random() < 0.66 ? 'crossroads' : 'internal';
                const experiences = experienceExamples[stageType];
                
                particle.userData = {
                    angle: angle,
                    radius: radius,
                    height: height,
                    speed: Math.random() * 0.02 + 0.01,
                    experience: experiences[Math.floor(Math.random() * experiences.length)],
                    type: stageType
                };
                
                particles.push(particle);
                scene.add(particle);
            }
            
            // Create journey path
            createJourneyPath();
            
            // Initialize audio context
            if (window.AudioContext || window.webkitAudioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            // Setup speed slider
            const speedSlider = document.getElementById('speed-slider');
            if (speedSlider) {
                speedSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    speedMultiplier = value < 0.05 ? 0 : value;
                    
                    const speedValueElement = document.getElementById('speed-value');
                    if (speedValueElement) {
                        speedValueElement.textContent = speedMultiplier === 0 ? 'åœæ­¢' : speedMultiplier.toFixed(1) + 'x';
                    }
                });
                
                speedMultiplier = 1.0;
                document.getElementById('speed-value').textContent = '1.0x';
            }
            
            // Initialize sub-stage controls
            updateSubStageControls();
            
            // Remove loader
            document.getElementById('loader').style.display = 'none';
            
            // Start animation
            animate();
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                // Single touch - rotation
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // Two touches - pinch zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                // Single touch - rotation
                const deltaX = e.touches[0].clientX - touchStartX;
                const deltaY = e.touches[0].clientY - touchStartY;
                
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
                
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // Two touches - pinch zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const scale = distance / touchStartDistance;
                cameraDistance *= (2 - scale);
                cameraDistance = Math.max(5, Math.min(30, cameraDistance));
                camera.position.normalize().multiplyScalar(cameraDistance);
                
                touchStartDistance = distance;
            }
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
        }
        
        function createJourneyPath() {
            // Create multi-layered light emanation system
            journeyPath = new THREE.Group();
            journeyPath.name = 'lightEmanation';
            
            // Adjust light layers for mobile
            const lightLayers = isMobile ? [
                { size: 1.5, opacity: 0.15, speed: 1.0 },
                { size: 3.5, opacity: 0.08, speed: 0.6 },
                { size: 5, opacity: 0.05, speed: 0.4 }
            ] : [
                { size: 1.5, opacity: 0.15, speed: 1.0 },
                { size: 2.5, opacity: 0.1, speed: 0.8 },
                { size: 3.5, opacity: 0.08, speed: 0.6 },
                { size: 5, opacity: 0.05, speed: 0.4 },
                { size: 7, opacity: 0.04, speed: 0.3 }
            ];
            
            lightLayers.forEach((layer, index) => {
                const lightGeometry = new THREE.SphereGeometry(layer.size, isMobile ? 16 : 32, isMobile ? 16 : 32);
                
                const lightMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(0.55 + index * 0.05, 0.6, 0.4),
                    transparent: true,
                    opacity: layer.opacity,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                
                const lightMesh = new THREE.Mesh(lightGeometry, lightMaterial);
                lightMesh.userData = { 
                    layerIndex: index, 
                    baseOpacity: layer.opacity,
                    material: lightMaterial,
                    speed: layer.speed
                };
                journeyPath.add(lightMesh);
            });
            
            // Reduce particle count for mobile
            const sparkParticleCount = isMobile ? 30 : 60;
            for (let i = 0; i < sparkParticleCount; i++) {
                const radius = Math.random() * 8 + 2;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                
                const sparkGeometry = new THREE.SphereGeometry(0.015, 6, 6);
                
                const hue = (i / sparkParticleCount + Math.random() * 0.1) % 1;
                const sparkMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(hue, 0.6, 0.4),
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                spark.position.set(x, y, z);
                
                spark.userData = {
                    isSparkParticle: true,
                    originalPosition: new THREE.Vector3(x, y, z),
                    particleIndex: i,
                    baseColor: hue
                };
                
                journeyPath.add(spark);
            }
            
            journeyPath.visible = false;
            scene.add(journeyPath);
        }
        
        function showStage(stage) {
            currentStage = stage;
            
            // Update main stage buttons
            document.querySelectorAll('.main-stage-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update sub-stage controls
            updateSubStageControls();
            
            // Select first sub-stage of the main stage
            const subStages = Object.keys(subStageData).filter(key => subStageData[key].parent === stage);
            if (subStages.length > 0) {
                showSubStage(subStages[0]);
            }
        }
        
        function updateSubStageControls() {
            const container = document.getElementById('sub-stage-controls');
            container.innerHTML = '';
            
            const subStages = Object.keys(subStageData).filter(key => subStageData[key].parent === currentStage);
            
            subStages.forEach(subStage => {
                const button = document.createElement('button');
                button.className = 'sub-stage-btn';
                button.textContent = subStage;
                button.onclick = () => showSubStage(subStage);
                if (subStage === currentSubStage) {
                    button.classList.add('active');
                }
                container.appendChild(button);
            });
        }
        
        function showSubStage(subStage) {
            currentSubStage = subStage;
            const data = subStageData[subStage];
            
            // Update UI
            document.getElementById('current-stage').textContent = data.name;
            document.getElementById('stage-description').textContent = data.description;
            document.getElementById('epistemological').textContent = data.epistemological;
            document.getElementById('intrapersonal').textContent = data.intrapersonal;
            document.getElementById('interpersonal').textContent = data.interpersonal;
            
            // Update buttons
            document.querySelectorAll('.sub-stage-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent === subStage) {
                    btn.classList.add('active');
                }
            });
            
            // Update progress nodes
            updateProgressNodes(subStage);
            
            // Play sound effect if enabled
            if (soundEnabled && audioContext) {
                playTransitionSound(data.intensity);
            }
        }
        
        function updateProgressNodes(activeStage) {
            const stages = ['Ea', 'Eb', 'Ec', 'EI', 'E-I', 'I-E', 'IE', 'Ia', 'Ib', 'Ic'];
            const activeIndex = stages.indexOf(activeStage);
            
            document.querySelectorAll('.progress-node').forEach((node, index) => {
                node.classList.remove('active', 'completed');
                if (index === activeIndex) {
                    node.classList.add('active');
                } else if (index < activeIndex) {
                    node.classList.add('completed');
                }
            });
        }
        
        function jumpToStage(stage) {
            // Determine parent stage
            const data = subStageData[stage];
            currentStage = data.parent;
            
            // Update main stage buttons
            document.querySelectorAll('.main-stage-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.includes(currentStage === 'external' ? 'å¤–çš„æ„å‘³å½¢æˆ' : 
                                           currentStage === 'crossroads' ? 'å²è·¯' : 'å†…çš„æ„å‘³å½¢æˆ')) {
                    btn.classList.add('active');
                }
            });
            
            // Update sub-stage controls and show the stage
            updateSubStageControls();
            showSubStage(stage);
        }
        
        function toggleAnimation() {
            animationRunning = !animationRunning;
            document.getElementById('animation-toggle').textContent = `è‡ªå‹•é€²è¡Œ: ${animationRunning ? 'ON' : 'OFF'}`;
        }
        
        function togglePath() {
            pathEnabled = !pathEnabled;
            if (journeyPath) {
                journeyPath.visible = pathEnabled;
            }
            
            const button = document.querySelector('.path-toggle');
            if (button) {
                button.textContent = `å†…ãªã‚‹å…‰: ${pathEnabled ? 'ON' : 'OFF'}`;
            }
            
            // éŸ³å£°ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
            if (pathEnabled && soundEnabled && audioContext) {
                try {
                    playTransitionSound(0.8);
                } catch (error) {
                    console.warn('Error playing sound:', error);
                }
            }
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            const button = document.querySelector('.sound-toggle');
            if (button) {
                button.textContent = soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
            }
        }
        
        function resetView() {
            cameraDistance = 10;
            camera.position.set(0, 5, cameraDistance);
            camera.lookAt(0, 0, 0);
        }
        
        // éŸ³å£°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®å®‰å…¨ãªåˆæœŸåŒ–
        function initAudioContext() {
            if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // ãƒ–ãƒ©ã‚¦ã‚¶ã®autoplay policyã«å¯¾å¿œ
                    if (audioContext.state === 'suspended') {
                        const resumeAudio = () => {
                            audioContext.resume().then(() => {
                                console.log('Audio context resumed');
                            });
                            document.removeEventListener('click', resumeAudio);
                            document.removeEventListener('keydown', resumeAudio);
                            document.removeEventListener('touchstart', resumeAudio);
                        };
                        
                        document.addEventListener('click', resumeAudio);
                        document.addEventListener('keydown', resumeAudio);
                        document.addEventListener('touchstart', resumeAudio);
                    }
                } catch (error) {
                    console.warn('Failed to initialize audio context:', error);
                    soundEnabled = false;
                }
            }
        }
        
        function closeTutorial() {
            document.getElementById('tutorial').style.display = 'none';
            tutorialShown = true;
        }
        
        function playTransitionSound(intensity) {
            if (!audioContext || audioContext.state === 'suspended') return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 200 + intensity * 600;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (error) {
                console.warn('Error playing sound:', error);
            }
        }
        
        function onParticleClick(event) {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(particles);
            
            if (intersects.length > 0) {
                const particle = intersects[0].object;
                const info = document.getElementById('particle-info');
                info.innerHTML = `
                    <strong>çµŒé¨“ã®ä¾‹ï¼š</strong><br>
                    "${particle.userData.experience}"<br><br>
                    <small>ã‚¿ã‚¤ãƒ—: ${particle.userData.type === 'external' ? 'å¤–çš„' : 
                                    particle.userData.type === 'crossroads' ? 'å²è·¯' : 'å†…çš„'}</small>
                `;
                info.style.display = 'block';
                
                if (!isMobile) {
                    info.style.left = event.clientX + 10 + 'px';
                    info.style.top = event.clientY + 10 + 'px';
                }
                
                setTimeout(() => {
                    info.style.display = 'none';
                }, 3000);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const data = subStageData[currentSubStage];
            
            // ã‚ˆã‚Šç¢ºå®Ÿãªæ¡ä»¶åˆ¤å®š
            const isAnimating = speedMultiplier > 0.01; // 0.01ä»¥ä¸‹ã¯åœæ­¢ã¨ã¿ãªã™
            
            // é€Ÿåº¦ãŒæœ‰åŠ¹ãªå ´åˆã®ã¿æ™‚é–“ã‚’é€²ã‚ã‚‹
            if (isAnimating) {
                time += 0.01 * speedMultiplier;
                
                // Animate core with null check
                if (core && data) {
                    const targetSize = data.coreSize;
                    core.scale.lerp(new THREE.Vector3(targetSize, targetSize, targetSize), 0.05);
                    
                    // Update core color
                    const targetColor = new THREE.Color(data.coreColor);
                    core.material.color.lerp(targetColor, 0.05);
                    core.material.emissive.lerp(targetColor, 0.05);
                    core.material.emissiveIntensity = data.intensity * (0.5 + Math.sin(time * 2) * 0.2);
                    
                    // Animate core glow with null check
                    if (core.children[0]) {
                        core.children[0].scale.setScalar(1 + Math.sin(time * 3) * 0.1);
                        core.children[0].material.opacity = 0.3 * data.intensity;
                    }
                }
                
                // Animate dimension rings with null checks
                if (dimensionRings.length > 0 && data) {
                    dimensionRings.forEach((ring, index) => {
                        if (ring && ring.material) {
                            ring.rotation.z += data.ringRotation * (index + 1) * 0.5 * speedMultiplier;
                            ring.rotation.y = Math.sin(time + index) * 0.1;
                            
                            // Pulsing effect
                            const scale = 1 + Math.sin(time * 2 + index) * 0.05;
                            ring.scale.set(scale, scale, 1);
                            
                            // Update ring opacity based on stage
                            ring.material.opacity = 0.3 + data.intensity * 0.5;
                            
                            // Animate orbital particles
                            if (ring.children) {
                                ring.children.forEach((orbital, j) => {
                                    if (orbital && orbital.position) {
                                        const angle = (j / ring.children.length) * Math.PI * 2 + time * (index + 1) * 0.5;
                                        const radius = 2 + index;
                                        orbital.position.set(
                                            Math.cos(angle) * radius,
                                            Math.sin(time * 2 + j) * 0.2,
                                            Math.sin(angle) * radius
                                        );
                                    }
                                });
                            }
                        }
                    });
                }
                
                // Animate particles with null checks
                if (particles.length > 0 && data) {
                    particles.forEach((particle, index) => {
                        if (particle && particle.userData && particle.material) {
                            const userData = particle.userData;
                            userData.angle += userData.speed * speedMultiplier;
                            
                            // Adjust radius based on stage
                            const targetRadius = userData.radius * (data.particleSpread / 5);
                            const currentRadius = Math.sqrt(particle.position.x ** 2 + particle.position.z ** 2);
                            const newRadius = currentRadius + (targetRadius - currentRadius) * 0.02;
                            
                            particle.position.x = Math.cos(userData.angle) * newRadius;
                            particle.position.z = Math.sin(userData.angle) * newRadius;
                            particle.position.y = userData.height * Math.sin(time + index * 0.1) * 0.5;
                            
                            // Particle glow and opacity based on stage affinity
                            const stageAffinity = 
                                (userData.type === 'external' && currentStage === 'external') ||
                                (userData.type === 'crossroads' && currentStage === 'crossroads') ||
                                (userData.type === 'internal' && currentStage === 'internal');
                            
                            particle.material.emissiveIntensity = stageAffinity ? 
                                0.8 + Math.sin(time * 3 + index) * 0.2 : 
                                0.2 + Math.sin(time * 3 + index) * 0.1;
                            
                            particle.material.opacity = stageAffinity ? 0.9 : 0.3;
                        }
                    });
                }
                
                // Animate journey path (light emanation) if visible
                if (journeyPath && journeyPath.visible && data) {
                    const stages = ['Ea', 'Eb', 'Ec', 'EI', 'E-I', 'I-E', 'IE', 'Ia', 'Ib', 'Ic'];
                    const currentStageIndex = stages.indexOf(currentSubStage);
                    const growthProgress = Math.max(0, currentStageIndex) / (stages.length - 1);
                    
                    // Update light layers and particles
                    journeyPath.children.forEach(child => {
                        try {
                            if (child && child.userData && child.userData.layerIndex !== undefined) {
                                // ã‚¹ãƒ•ã‚£ã‚¢ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                                const layer = child.userData;
                                
                                if (child.material && child.material.color) {
                                    const hue = (0.55 + growthProgress * 0.2 + time * layer.speed * 0.05) % 1;
                                    child.material.color.setHSL(hue, 0.6, 0.4);
                                    
                                    const baseOpacity = layer.baseOpacity || 0.15;
                                    const intensity = Math.min(data.intensity * 0.6, 0.8);
                                    child.material.opacity = baseOpacity * intensity * (0.3 + growthProgress * 0.4);
                                }
                                
                                if (child.rotation) {
                                    child.rotation.y += 0.001 * (layer.layerIndex + 1) * speedMultiplier;
                                    child.rotation.x = Math.sin(time * layer.speed + layer.layerIndex) * 0.03;
                                    child.rotation.z = Math.cos(time * layer.speed * 0.7 + layer.layerIndex) * 0.02;
                                    
                                    const pulse = 1 + Math.sin(time * layer.speed * 1.2) * 0.03 * growthProgress;
                                    child.scale.setScalar(pulse);
                                }
                                
                            } else if (child && child.userData && child.userData.isSparkParticle) {
                                const userData = child.userData;
                                const originalPos = userData.originalPosition;
                                
                                const expansion = 1 + Math.sin(time * 0.3 + originalPos.length() * 0.1) * 0.2 * growthProgress;
                                const rotationY = time * 0.05 * speedMultiplier;
                                
                                const rotatedX = originalPos.x * Math.cos(rotationY) - originalPos.z * Math.sin(rotationY);
                                const rotatedZ = originalPos.x * Math.sin(rotationY) + originalPos.z * Math.cos(rotationY);
                                
                                child.position.set(
                                    rotatedX * expansion,
                                    originalPos.y * expansion + Math.sin(time * 1.5 + userData.particleIndex * 0.1) * 0.1,
                                    rotatedZ * expansion
                                );
                                
                                if (child.material) {
                                    const hue = (userData.baseColor + growthProgress * 0.1 + time * 0.02) % 1;
                                    child.material.color.setHSL(hue, 0.6, 0.4);
                                    child.material.opacity = 0.4 * (0.2 + growthProgress * 0.5);
                                }
                                
                                const sparkScale = 0.3 + Math.sin(time * 2 + userData.particleIndex) * 0.2 + growthProgress * 0.3;
                                child.scale.setScalar(sparkScale);
                            }
                        } catch (error) {
                            console.warn('Error animating journey path child:', error);
                        }
                    });
                }
            } else {
                // å®Œå…¨åœæ­¢çŠ¶æ…‹ - ã™ã¹ã¦ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åœæ­¢
                if (core && data) {
                    const targetSize = data.coreSize;
                    core.scale.lerp(new THREE.Vector3(targetSize, targetSize, targetSize), 0.05);
                    
                    const targetColor = new THREE.Color(data.coreColor);
                    core.material.color.lerp(targetColor, 0.05);
                    core.material.emissive.lerp(targetColor, 0.05);
                    core.material.emissiveIntensity = data.intensity * 0.5;
                    
                    if (core.children[0]) {
                        core.children[0].scale.setScalar(1);
                        core.children[0].material.opacity = 0.3 * data.intensity;
                    }
                }
                
                // ãƒªãƒ³ã‚°ã‚‚é™çš„çŠ¶æ…‹ã«
                if (dimensionRings.length > 0 && data) {
                    dimensionRings.forEach((ring, index) => {
                        if (ring && ring.material) {
                            ring.scale.set(1, 1, 1);
                            ring.material.opacity = 0.3 + data.intensity * 0.5;
                        }
                    });
                }
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚‚é™çš„çŠ¶æ…‹ã«
                if (particles.length > 0 && data) {
                    particles.forEach((particle, index) => {
                        if (particle && particle.userData && particle.material) {
                            const stageAffinity = 
                                (particle.userData.type === 'external' && currentStage === 'external') ||
                                (particle.userData.type === 'crossroads' && currentStage === 'crossroads') ||
                                (particle.userData.type === 'internal' && currentStage === 'internal');
                            
                            particle.material.emissiveIntensity = stageAffinity ? 0.8 : 0.2;
                            particle.material.opacity = stageAffinity ? 0.9 : 0.3;
                        }
                    });
                }
                
                // å†…ãªã‚‹å…‰ã‚‚é™çš„çŠ¶æ…‹ã«
                if (journeyPath && journeyPath.visible && data) {
                    const stages = ['Ea', 'Eb', 'Ec', 'EI', 'E-I', 'I-E', 'IE', 'Ia', 'Ib', 'Ic'];
                    const currentStageIndex = stages.indexOf(currentSubStage);
                    const growthProgress = Math.max(0, currentStageIndex) / (stages.length - 1);
                    
                    journeyPath.children.forEach(child => {
                        try {
                            if (child && child.userData && child.userData.layerIndex !== undefined) {
                                if (child.material && child.material.color) {
                                    const hue = (0.55 + growthProgress * 0.2) % 1;
                                    child.material.color.setHSL(hue, 0.6, 0.4);
                                    
                                    const baseOpacity = child.userData.baseOpacity || 0.15;
                                    const intensity = Math.min(data.intensity * 0.6, 0.8);
                                    child.material.opacity = baseOpacity * intensity * (0.3 + growthProgress * 0.4);
                                }
                                
                                if (child.scale) {
                                    child.scale.setScalar(1);
                                }
                                
                            } else if (child && child.userData && child.userData.isSparkParticle) {
                                child.position.copy(child.userData.originalPosition);
                                if (child.material) {
                                    const hue = (child.userData.baseColor + growthProgress * 0.1) % 1;
                                    child.material.color.setHSL(hue, 0.6, 0.4);
                                    child.material.opacity = 0.4 * (0.2 + growthProgress * 0.5);
                                }
                                child.scale.setScalar(0.3 + growthProgress * 0.3);
                            }
                        } catch (error) {
                            console.warn('Error animating journey path child:', error);
                        }
                    });
                }
            }
            
            // è‡ªå‹•é€²è¡Œã¯é€Ÿåº¦ãŒæœ‰åŠ¹ã§ã€ã‹ã¤animationRunningãŒtrueã®å ´åˆã®ã¿
            if (animationRunning && isAnimating && data) {
                const stages = ['Ea', 'Eb', 'Ec', 'EI', 'E-I', 'I-E', 'IE', 'Ia', 'Ib', 'Ic'];
                const currentIndex = stages.indexOf(currentSubStage);
                const progressTime = (time * 0.1) % stages.length;
                const targetIndex = Math.floor(progressTime);
                
                if (targetIndex !== currentIndex && targetIndex >= 0 && targetIndex < stages.length) {
                    jumpToStage(stages[targetIndex]);
                }
            }
            
            // å¸¸ã«ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼ˆè¡¨ç¤ºæ›´æ–°ã®ãŸã‚ï¼‰
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            checkDevice();
            
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
            }
        });
        
        // Initialize
        init();
    </script>
</body>
</html>
